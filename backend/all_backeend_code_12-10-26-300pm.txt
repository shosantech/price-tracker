github: https://github.com/shosantech/price-tracker
db.py:
import sqlite3
from config.settings import DB_PATH

def init_db():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()

    c.execute("""CREATE TABLE IF NOT EXISTS gold_prices (
        date TEXT PRIMARY KEY,
        close REAL,
        volume REAL,
        ma20 REAL,
        ma50 REAL,
        rsi REAL
    )""")

    c.execute("""CREATE TABLE IF NOT EXISTS news (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT,
        source TEXT,
        publishedAt TEXT,
        sentiment REAL
    )""")

    c.execute("""
CREATE TABLE IF NOT EXISTS news_volume (
    week_start TEXT PRIMARY KEY,
    total_articles INTEGER,
    average_sentiment REAL
)
""")

    conn.commit()
    conn.close()

def save_gold_price(data):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("""
        INSERT OR REPLACE INTO gold_prices (date, close, volume, ma20, ma50, rsi)
        VALUES (?, ?, ?, ?, ?, ?)
    """, (data['date'], data['close'], data['volume'], data['ma20'], data['ma50'], data['rsi']))
    conn.commit()
    conn.close()

def save_news(data):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("""
        INSERT INTO news (title, source, publishedAt, sentiment)
        VALUES (?, ?, ?, ?)
    """, (data['title'], data['source'], data['publishedAt'], data['sentiment']))
    conn.commit()
    conn.close()

def save_news_volume(week_start, total_articles, average_sentiment):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("""
        INSERT OR REPLACE INTO news_volume (week_start, total_articles, average_sentiment)
        VALUES (?, ?, ?)
    """, (week_start, total_articles, average_sentiment))
    conn.commit()
    conn.close()

def load_past_volumes():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()

    c.execute("SELECT week_start, total_articles, average_sentiment FROM news_volume ORDER BY week_start DESC")
    rows = c.fetchall()

    conn.close()

    # Return list of (week_start, count)
    return rows

# In database/db.py

def load_past_avg_sentiments():
    """
    Returns a list of past weekly average sentiments from the database.
    """
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    cursor.execute("SELECT average_sentiment FROM news_volume ORDER BY week_start ASC")
    rows = cursor.fetchall()
    conn.close()

    # Each row is a tuple (avg_sentiment,), so extract the float
    return [row[0] for row in rows]

news_fetcher:
import requests
from datetime import datetime, timedelta
from config.settings import NEWS_API_KEY

def fetch_gold_news_past_week():
    url = "https://newsapi.org/v2/everything"

    # Only get news from the past 7 days
    today = datetime.utcnow()
    week_ago = today - timedelta(days=7)
    from_param = week_ago.strftime("%Y-%m-%dT%H:%M:%SZ")  # ISO 8601 format

    params = {
        "q": "gold price OR gold stock OR gold market OR gold trading OR gold futures OR gold bullion OR gold investment OR gold ounce OR gold expected OR gold gains",
        "searchIn": "title,description",
        "language": "en",
        "from": from_param,
        "pageSize": 50,
        "sortBy": "publishedAt",
        "apiKey": NEWS_API_KEY
    }

    try:
        response = requests.get(url, params=params)
        response.raise_for_status()
        data = response.json()
    except Exception as e:
        print(f"Error fetching gold news: {e}")
        return [], 0

    total_results = data.get("totalResults", 0)
    articles = []

    for a in data.get("articles", []):
        articles.append({
            "source": a.get("source", {}).get("name", "Unknown"),
            "publishedAt": a.get("publishedAt"),
            "title": a.get("title"),
            "url": a.get("url")
        })

    # Sort from most recent to oldest just in case
    articles.sort(key=lambda x: x["publishedAt"], reverse=True)

    return articles, total_results

if __name__ == "__main__":
    articles, total_results = fetch_gold_news_past_week()
    print(f"Total results in past week: {total_results}\n")
    for i, article in enumerate(articles, start=1):
        print(f"{i}. {article['source']} - {article['title']} - {article['publishedAt']}")
        print(f"URL: {article['url']}\n")
price_fetcher:
import yfinance as yf
import pandas as pd

def fetch_gold_prices(period="1y", interval="1d"):
    ticker = yf.Ticker("GC=F")  # Gold Futures
    df = ticker.history(period=period, interval=interval)

    if df.empty:
        raise Exception("Failed to fetch gold prices from Yahoo Finance.")

    df = df[['Close', 'Volume']]
    df.reset_index(inplace=True)
    return df
combined_signal.py:
def convert_to_score(signal):
    if signal == "BUY":
        return 1
    elif signal == "SELL":
        return -1
    return 0  # HOLD


def generate_combined_signal(technical_signal, sentiment_signal):
    """
    Weighted fusion:
    - Technical weight: 2
    - Sentiment weight: 1
    """

    tech_score = convert_to_score(technical_signal)
    sent_score = convert_to_score(sentiment_signal)

    final_score = (tech_score * 2) + (sent_score * 1)

    if final_score >= 2:
        return "BUY"
    elif final_score <= -2:
        return "SELL"
    else:
        return "HOLD"
    
    
decision_engine.py:
import numpy as np

# -----------------------------
# TECHNICAL SIGNAL
# -----------------------------
def generate_technical_signal(price_df, volume_flag, price_period=60):
    """
    Generate BUY / SELL / HOLD signal based on technical indicators:
    - Trend (MA20 vs MA50)
    - RSI
    - Price vs N-day range (default 60)
    - Volume spike
    Returns: signal, weighted_score, confidence (0-1)
    """

    # ----- Trend -----
    ma20 = price_df["MA_20"].iloc[-1]
    ma50 = price_df["MA_50"].iloc[-1]
    trend = 1 if ma20 > ma50 else -1 if ma20 < ma50 else 0

    # ----- RSI -----
    rsi = price_df["RSI"].iloc[-1]
    rsi_score = 1 if rsi < 40 else -1 if rsi > 70 else 0

    # ----- Price Structure -----
    close = price_df["Close"].iloc[-1]
    recent_min = price_df["Close"].rolling(price_period).min().iloc[-1]
    recent_max = price_df["Close"].rolling(price_period).max().iloc[-1]
    price_score = 1 if close <= recent_min * 1.05 else -1 if close >= recent_max * 0.97 else 0

    # ----- Volume Spike -----
    volume_score = 1 if volume_flag else 0

    # ----- Weighted Score -----
    weights = {"trend": 0.35, "rsi": 0.20, "price": 0.25, "volume": 0.10}
    weighted_score = (
        trend*weights["trend"] +
        rsi_score*weights["rsi"] +
        price_score*weights["price"] +
        volume_score*weights["volume"]
    )

    # ----- Signal -----
    if weighted_score >= 0.6:
        signal = "BUY"
    elif weighted_score <= -0.6:
        signal = "SELL"
    else:
        signal = "HOLD"

    # ----- Confidence -----
    max_possible = sum(weights.values())  # max absolute weighted sum
    confidence = round(abs(weighted_score) / max_possible * 100, 1)  # percent

    return signal, weighted_score, confidence


# -----------------------------
# SENTIMENT SIGNAL
# -----------------------------
def generate_sentiment_signal(sentiment_list):
    avg_sentiment = np.mean([a["sentiment"] for a in sentiment_list])
    if avg_sentiment < -0.15:
        signal = "BUY"
    elif avg_sentiment > 0.15:
        signal = "SELL"
    else:
        signal = "HOLD"

    # Confidence as magnitude of sentiment
    confidence = round(min(abs(avg_sentiment)*100, 100),1)
    return signal, avg_sentiment, confidence


# -----------------------------
# COMBINED SIGNAL
# -----------------------------
def generate_combined_signal(price_df, sentiment_list, volume_flag, price_period=60):
    tech_signal, tech_score, tech_conf = generate_technical_signal(price_df, volume_flag, price_period)
    sent_signal, sent_score, sent_conf = generate_sentiment_signal(sentiment_list)

    # Weighted fusion: technical weight=2, sentiment weight=1
    combined_score = (tech_score*2) + (1 if sent_signal=="BUY" else -1 if sent_signal=="SELL" else 0)
    if combined_score >= 2:
        combined_signal = "BUY"
    elif combined_score <= -2:
        combined_signal = "SELL"
    else:
        combined_signal = "HOLD"

    # Combined confidence normalized
    max_possible = 2 + 1  # weights sum
    combined_confidence = round(abs(combined_score)/max_possible*100,1)

    return combined_signal, combined_score, combined_confidence

sentiment.py:
from vaderSentiment.vaderSentiment import SentimentIntensityAnalyzer
from datetime import datetime, timedelta
import numpy as np

analyzer = SentimentIntensityAnalyzer()

def calculate_weighted_sentiment(sentiment_list):
    credible_sources = ["Reuters", "Bloomberg", "CNBC", "BusinessLine", "The Times of India"]
    forward_keywords = ["expansion", "acquisition", "new contract", "market entry", "FDA approval"]

    weighted_sentiments = []
    for a in sentiment_list:
        score = a["sentiment"]
        weight = 2 if a["source"] in credible_sources else 1
        if any(kw.lower() in a["title"].lower() for kw in forward_keywords):
            weight *= 1.5
        weighted_sentiments.append(score * weight)

    return sum(weighted_sentiments) / max(len(weighted_sentiments), 1)

def compute_sentiment(articles, past_volumes, past_avg_sentiments=None):
    """
    Compute sentiment for a list of articles with weekly metrics.
    - articles: list of news dicts
    - past_volumes: list of tuples [(week_start, total_articles), ...]
    - past_avg_sentiments: list of floats of previous weeks' avg_sentiment
    Returns:
        sentiment_list, volume_flag, this_week, avg_weekly, volume_increase, past_avg_sentiments
    """

    sentiment_list = []
    for a in articles:
        score = analyzer.polarity_scores(a["title"])["compound"]
        sentiment_list.append({
            "title": a["title"],
            "source": a.get("source", "Unknown"),
            "publishedAt": a["publishedAt"],
            "sentiment": score
        })

    # Weekly metrics
    this_week = len(articles)
    avg_weekly = np.mean([v[1] for v in past_volumes]) if past_volumes else this_week

    # Detect volume spike
    volume_increase = ((this_week - avg_weekly) / avg_weekly) * 100 if avg_weekly else 0
    volume_flag = volume_increase >= 20  # Example threshold

    # Compute current week's average weighted sentiment
    current_avg_sentiment = calculate_weighted_sentiment(sentiment_list)

    # Append to historical sentiments
    if past_avg_sentiments is None:
        past_avg_sentiments = []
    past_avg_sentiments.append(current_avg_sentiment)

    return sentiment_list, volume_flag, this_week, avg_weekly, volume_increase, past_avg_sentiments

def generate_sentiment(price_df, sentiment_list, volume_flag, past_sentiments=None):
    """
    Generates a sentiment-based signal using current and optionally historical weekly sentiment.
    - price_df: dataframe with gold prices & technical indicators
    - sentiment_list: current week's articles sentiment
    - volume_flag: current week's volume spike flag
    - past_sentiments: list of avg_sentiment from past weeks
    """

    # 1. Current week's weighted sentiment
    avg_sentiment = calculate_weighted_sentiment(sentiment_list)

    # 2. Historical context adjustment (optional)
    if past_sentiments and len(past_sentiments) > 0:
        hist_mean = np.mean(past_sentiments)
        hist_std = np.std(past_sentiments)
        # Z-score of current sentiment
        z_score = (avg_sentiment - hist_mean) / (hist_std + 1e-6)
    else:
        z_score = 0  # No past data

    # 3. Sentiment score
    # Use z_score if historical data exists, else use absolute thresholds
    if past_sentiments:
        if z_score > 0.5:
            sentiment_score = 1
        elif z_score < -0.5:
            sentiment_score = -1
        else:
            sentiment_score = 0
    else:
        if avg_sentiment > 0.2:
            sentiment_score = 1
        elif avg_sentiment < -0.2:
            sentiment_score = -1
        else:
            sentiment_score = 0

    # 4. Technical score
    ma20 = price_df["MA_20"].iloc[-1]
    ma50 = price_df["MA_50"].iloc[-1]
    trend_score = 1 if ma20 > ma50 else -1 if ma20 < ma50 else 0

    rsi = price_df["RSI"].iloc[-1]
    rsi_score = 1 if rsi < 30 else -1 if rsi > 70 else 0

    # 5. Price context score
    close = price_df["Close"].iloc[-1]
    recent_min = price_df["Close"].rolling(30).min().iloc[-1]
    recent_max = price_df["Close"].rolling(30).max().iloc[-1]
    price_score = 1 if close <= recent_min * 1.05 else -1 if close >= recent_max * 0.95 else 0

    # 6. Combine scores
    final_score = sentiment_score + trend_score + rsi_score + price_score
    if final_score >= 2:
        signal = "BUY"
    elif final_score <= -2:
        signal = "SELL"
    else:
        signal = "HOLD"

    print("DEBUG: avg_sentiment:", avg_sentiment, 
          "z_score:", round(z_score, 2),
          "sentiment_score:", sentiment_score,
          "final_score:", final_score,
          "signal:", signal)

    return signal, avg_sentiment
technicals.py:
import pandas as pd

# -----------------------------
# INDICATORS
# -----------------------------
def compute_technicals(df):
    df['MA_20'] = df['Close'].rolling(window=20).mean()
    df['MA_50'] = df['Close'].rolling(window=50).mean()
    df['RSI'] = compute_rsi(df['Close'], 14)
    return df


def compute_rsi(series, window=14):
    delta = series.diff()
    gain = (delta.where(delta > 0, 0)).rolling(window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window).mean()
    rs = gain / loss
    return 100 - (100 / (1 + rs))


# -----------------------------
# PRICE STRUCTURE FLAGS
# -----------------------------
def price_structure_flag(df, window):
    """
    Returns:
    +1  â†’ near support (buy zone)
    -1  â†’ near resistance (sell zone)
     0  â†’ neutral
    """
    close = df["Close"].iloc[-1]
    low = df["Close"].rolling(window).min().iloc[-1]
    high = df["Close"].rolling(window).max().iloc[-1]

    if close <= low * 1.05:
        return 1
    elif close >= high * 0.97:
        return -1
    else:
        return 0


# -----------------------------
# TECHNICAL SIGNAL (60D ONLY)
# -----------------------------
# -----------------------------
# TECHNICAL SIGNAL (60D ONLY) WITH CONFIDENCE
# -----------------------------
def generate_technical(df, volume_flag=False):
    """
    Medium/long-term gold technical signal.
    Uses ONLY 60-day price structure for decision.
    Includes weighted confidence score based on components.
    """

    latest = df.iloc[-1]

    # -------- Trend (direction) --------
    if latest["MA_20"] > latest["MA_50"]:
        trend_score = 1
    elif latest["MA_20"] < latest["MA_50"]:
        trend_score = -1
    else:
        trend_score = 0

    # -------- RSI (timing) --------
    if latest["RSI"] < 40:
        rsi_score = 1
    elif latest["RSI"] > 70:
        rsi_score = -1
    else:
        rsi_score = 0

    # -------- Price Structure --------
    structure_45 = price_structure_flag(df, 45)
    structure_60 = price_structure_flag(df, 60)
    structure_90 = price_structure_flag(df, 90)
    price_score = structure_60  # for 60-day signal

    # -------- Volume --------
    volume_score = 1 if volume_flag else 0

    # -------- FINAL SIGNAL (60D only) --------
    final_score = trend_score + rsi_score + price_score + volume_score
    if final_score >= 2:
        signal = "BUY"
    elif final_score <= -2:
        signal = "SELL"
    else:
        signal = "HOLD"

    # -------- TECHNICAL CONFIDENCE --------
    weights = {"trend": 0.35, "rsi": 0.20, "price": 0.25, "volume": 0.10}
    weighted_sum = (
        abs(trend_score * weights["trend"]) +
        abs(rsi_score * weights["rsi"]) +
        abs(price_score * weights["price"]) +
        abs(volume_score * weights["volume"])
    )
    max_weighted = sum(weights.values())
    technical_confidence = round((weighted_sum / max_weighted) * 100, 1)

    return {
        "signal": signal,
        "score": final_score,
        "confidence": technical_confidence,
        "components": {
            "trend": trend_score,
            "rsi": rsi_score,
            "price_structure_45": structure_45,
            "price_structure_60": structure_60,
            "price_structure_90": structure_90,
            "volume": volume_score
        }
    }
app.py:
from flask import Flask, jsonify
from flask_cors import CORS
from datetime import datetime, timedelta

from fetchers.price_fetcher import fetch_gold_prices
from fetchers.news_fetcher import fetch_gold_news_past_week

from processors.technicals import compute_technicals, generate_technical
from processors.sentiment import compute_sentiment, generate_sentiment
from fusion import decision_engine
from fusion.combined_signal import generate_combined_signal

from database.db import (
    init_db,
    save_gold_price,
    save_news,
    save_news_volume,
    load_past_volumes,
    load_past_avg_sentiments,
)

app = Flask(__name__)
CORS(app)
init_db()


@app.route("/analyze", methods=["GET"])
def analyze():

    # --------------------------
    # 1. FETCH + PROCESS PRICES
    # --------------------------
    price_df = fetch_gold_prices(period="1y", interval="1d")
    price_df = compute_technicals(price_df)

    # Technical signal (60-day based)
    technical = generate_technical(price_df)
    
    technical_signal = technical["signal"]
    technical_confidence =technical["confidence"]


    # --------------------------
    # 2. NEWS + SENTIMENT
    # --------------------------
    articles, _ = fetch_gold_news_past_week()

    past_volumes = load_past_volumes()
    past_avg_sentiments = load_past_avg_sentiments()

    sentiment_list, volume_flag, this_week, avg_weekly, volume_increase, _ = compute_sentiment(
        articles,
        past_volumes,
        past_avg_sentiments
    )

    past_avg_sentiments = None

    sentiment_signal, avg_sentiment = generate_sentiment(price_df, sentiment_list, volume_flag, past_avg_sentiments)
    sentiment_confidence = min(abs(avg_sentiment) * 100, 100)


    # --------------------------
    # 3. SAVE WEEKLY SENTIMENT
    # --------------------------
    week_start = (
        datetime.utcnow() - timedelta(days=datetime.utcnow().weekday())
    ).strftime("%Y-%m-%d")

    save_news_volume(week_start, this_week, avg_sentiment)

    # --------------------------
    # 4. SAVE PRICE HISTORY
    # --------------------------
    for _, row in price_df.iterrows():
        save_gold_price({
            "date": row["Date"].strftime("%Y-%m-%d"),
            "close": row["Close"],
            "volume": row["Volume"],
            "ma20": row["MA_20"],
            "ma50": row["MA_50"],
            "rsi": row["RSI"],
        })

    # --------------------------
    # 5. SAVE NEWS
    # --------------------------
    for article in sentiment_list:
        save_news(article)

    # --------------------------
    # 6. COMBINED SIGNAL
    # --------------------------
        combined_signal = generate_combined_signal(technical_signal, sentiment_signal)
    
    # --------------------------
    # Combined confidence (weighted sum)
    # --------------------------

    combined_confidence = round(
        (technical_confidence * 0.7) + (sentiment_confidence * 0.3), 1
    )


    # 6ï¸âƒ£ How confidence maps to behavior (recommended)
    # Confidence	Signal Meaning	Suggested Action
    # 85â€“100%	Strong alignment	Aggressive buy / add
    # 70â€“84%	Healthy trend	Buy / scale in
    # 55â€“69%	Mixed signals	Hold / small entries
    # 40â€“54%	Weak alignment	Wait
    # < 40%	Risky	Avoid / exit

    # So 70% BUY = lower-risk trend participation, not hype.


    # --------------------------
    # 7. API RESPONSE
    # --------------------------
    return jsonify({
        
    "week_start": week_start,
    "this_week_articles": int(this_week),
    "average_weekly_articles": float(avg_weekly),
    "volume_increase_percent": float(volume_increase),
    "news_volume_spike": bool(volume_flag),

    "technical": technical,
    "technical_confidence": technical["confidence"],
    "sentiment_signal": sentiment_signal,
    "combined_signal": combined_signal,
     "combined_confidence": combined_confidence,
    # "combined_score": combined_score,
    # "combined_confidence": combined_conf,

    "sentiment": sentiment_list,
})


## What Signal means:

## 1ï¸âƒ£ Trend:     "Are we allowed to buy?"
## 2ï¸âƒ£ Structure: "Is price favorable?"
## 3ï¸âƒ£ RSI:       "Is momentum stretched?"
## 4ï¸âƒ£ Volume:    "Is this move real?"

#Final clarity statement (lock this in)

##Trend decides direction
##Structure decides value
##RSI decides timing
##Volume decides confidence

##########

if __name__ == "__main__":
    print("ðŸ”¥ Flask API running at http://127.0.0.1:5000")
    app.run(debug=True)
